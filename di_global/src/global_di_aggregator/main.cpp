#include <iostream>
#include <fstream>
#include "DelimFileReader.hpp"
#include "FileIterator.hpp"
#include "CppTargetAggregator.hpp"
#include "HppTargetAggregator.hpp"

using FileSystem::PathType;

const std::string CAUTION = "/**\n"
                            " * This File is generated by global_di_aggregator.\n"
                            " * Please, never modify it manually.\n"
                            " */\n"
                            "\n";

const std::string HPP_DEFAULT = CAUTION +
                                "#ifndef SUBSCRIBE_ALL_GLOBAL_DI_HPP_\n"
                                "#define SUBSCRIBE_ALL_GLOBAL_DI_HPP_\n"
                                "\n"
                                "void subscribe_all_dependencies();\n"
                                "\n"
                                "#endif //SUBSCRIBE_ALL_GLOBAL_DI_HPP_";

const std::string CPP_DEFAULT = CAUTION;

void write_all(const PathType& file, const FileSystem::FileContentType& content)
{
    PathType parent_directory = file.parent_path();

    if (!std::filesystem::exists(parent_directory))
    {
        std::filesystem::create_directories(parent_directory);
    }

    std::ofstream outputFile(file);

    if (outputFile.is_open())
    {
        outputFile << content;
        outputFile.close();
        std::cout << "Successful output to " << file.string() << std::endl;
    }
    else
    {
        std::cerr << "Error opening the file: " << file.string() << std::endl;
    }
}

int main(int argc, char* argv[])
{
    if (argc != 5)
    {
        std::cerr << "Usage: " << argv[0] << " <root> <target_hpp> <target_cpp> <udil|dynamic>\n";
        return EXIT_FAILURE;
    }

    std::cout << "root: " << argv[1] << std::endl;
    std::cout << "target hpp: " << argv[2] << std::endl;
    std::cout << "target cpp: " << argv[3] << std::endl;
    std::cout << "mode: " << argv[4] << std::endl;

    const std::string root = argv[1];
    const std::string target_hpp = argv[2];
    const std::string target_cpp = argv[3];
    const std::string mode = argv[4];

    if (mode != "dynamic" && mode != "udil")
    {
        std::cerr << "Error: Unknown mode: " << mode << std::endl;
        return EXIT_FAILURE;
    }

    FileIterator file_iterator { root, L"\\w+\\.hppdi$"};

    auto aggregator = [&mode]() -> std::unique_ptr<IDataAggregator> {
        if (mode == "dynamic") {
            return std::make_unique<CppTargetAggregator>();
        }
        else if (mode == "udil") {
            return std::make_unique<HppTargetAggregator>();
        }
        else {
            // Unreachable default
            return std::make_unique<CppTargetAggregator>();
        }
    }();

    for
    (
        auto file_path_optional = file_iterator.next_file();
        file_path_optional.has_value();
        file_path_optional = file_iterator.next_file()
    )
    {
        const auto& file_path = *file_path_optional;
        std::wcout << file_path.c_str() << ":" << std::endl;
        aggregator->process_single_unit(file_path);
    }

    const auto aggregated_file = aggregator->get_aggregated_data();

    if (mode == "dynamic")
    {
        write_all(target_hpp, HPP_DEFAULT);
        write_all(target_cpp, CAUTION + aggregated_file);
    }
    else
    {
        write_all(target_hpp, CAUTION + aggregated_file);
        write_all(target_cpp, CPP_DEFAULT);
    }


    return EXIT_SUCCESS;
}